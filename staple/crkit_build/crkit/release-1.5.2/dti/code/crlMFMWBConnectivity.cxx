/*
 * Copyright (c) 2008-2011 Children's Hospital Boston.
 *
 * This software is licensed by the copyright holder under the terms of the
 * Open Software License version 3.0.
 * http://www.opensource.org/licenses/osl-3.0.php
 *
 * Attribution Notice.
 *
 * This research was carried out in the Computational Radiology Laboratory of
 * Children's Hospital, Boston and Harvard Medical School.
 * http://www.crl.med.harvard.edu
 * For more information contact: simon.warfield@childrens.harvard.edu
 *
 * This research work was made possible by Grant Number R01 RR021885 (Principal
 * Investigator: Simon K. Warfield, Ph.D.) to Children's Hospital, Boston
 * from the National Center for Research Resources (NCRR), a component of the
 * National Institutes of Health (NIH).
*/

#define MULTITHREAD_VERSION

#include <itkOrientedImage.h>
#include <itkImageFileReader.h>
#include <itkImageFileWriter.h>

#include "configuration.h"
#include "tclap/CmdLine.h"
#include <limits.h>

#ifdef WIN32
#define snprintf _snprintf
#define PATH_MAX 512
#endif

#ifdef _MSC_VER
  #pragma warning( disable: 4996 )
#endif

#include <math.h>
#include <float.h>

#include <vnl/vnl_matrix_fixed.h>
#include <vnl/vnl_det.h>

#include "crlMFMWBConnectivity.h"

// Input: A set of tensor images, a labelled region of interest image
// Output: Streamline tracts generated by Euler integration.

int main(int argc, char **argv)
{

	// Define the command line object, and insert a message
	// that describes the program.
	TCLAP::CmdLine cmd("Computational Radiology Laboratory", ' ',
		CRKIT_VERSION_STRING );

	TCLAP::SwitchArg noProgressArg	("","noprogress",
		"Disable the output of the whole brain connectivity progress (useful for debugging).", cmd, false);

#ifdef MULTITHREAD_VERSION
	TCLAP::ValueArg<unsigned int>	argProc("p","proc",	
		"Set the number of processors",	false, 
		1, "Nb Proc", 
		cmd);
#endif

	TCLAP::ValueArg<double > tractSimplifyArg("", "tractsimplify",
		"Define the minimum angle (in degrees) two consecutive points should have along each tract. Used to prune the tracts. (default: 0degrees = OFF)", false,
		0, "Angle",
		cmd);

	TCLAP::ValueArg<double > faMomentumArg("", "famomentum",
		"Fractional Anisotropy Momentum (default: 0.5)", false,
		0.5, "fa momentum",
		cmd);

	TCLAP::ValueArg<double > angleMomentumArg("", "anglemomentum",
		"Angle Momentum  (default: 0.5)", false,
		0.5, "angle momentum",
		cmd);

	TCLAP::ValueArg<double > directionMomentumArg("d", "directionmomentum",
		"Direction Momentum  (default: 0.5)", false,
		0.5, "direction momentum",
		cmd);

	TCLAP::ValueArg<double > tendFractionArg("t", "tendfraction",
		"Tensor Deflection Fraction vs Eigenvector Fraction (default: 0.5)", false,
		0.5, "tensor deflection fraction",
		cmd);

	TCLAP::ValueArg<unsigned int> tractSeedsPerVoxelArg("n", "numtractseeds",
		"Number of Tract Seeds Per Voxel (default: 1)", false,
		1, "number of tract seeds per voxel",
		cmd);

	TCLAP::ValueArg<unsigned int> stepsPerVoxelArg("s", "stepspervoxel",
		"Number of Steps per Voxel (default: 3)", false,
		3, "number of steps per voxel",
		cmd);


	std::vector<std::string> strInterpModes;
	strInterpModes.push_back("none");
	strInterpModes.push_back("euclidean");
	strInterpModes.push_back("logeuclidean");
	TCLAP::ValuesConstraint<std::string> interpModesArg(strInterpModes);
	TCLAP::ValueArg<std::string> interpolationArg("","interp","Tensor interpolation mode : none, euclidean interpolation or log-euclidean interpolation (default: logeuclidean)",false,"logeuclidean", &interpModesArg, cmd);

	TCLAP::ValueArg<double > faArg("f", "famin",
		"Minimum FA Value (default: 0.2)", false,
		0.2, "minimum fa value",
		cmd);

	TCLAP::ValueArg<double > angleMaxArg("a", "anglemax",
		"Maximum Angle Value in degrees (default: 30.0)", false,
		30, "maximum angle value",
		cmd);

	TCLAP::ValueArg<std::string> dilatedLabelsArg("", "dilatedlabels",
		"[ConnectivityMatrix mode only] Output the dilated labels image", false,
		"", "output label image",
		cmd);

	TCLAP::ValueArg<unsigned int> dilateLabelsArg("", "dilatelabels",
		"[ConnectivityMatrix mode only] Dilate the input labels (default: 0)", false,
		0, "number of voxels",
		cmd);

	TCLAP::ValueArg<std::string> densityFileArg("", "outputdensity",
		"[ConnectivityMatrix mode only] Output the density map for each pair of region. The produced files will have file name [base file name]_l{label1}_l{label2}.nrrd.", false,
		"", "base file name",
		cmd);

	TCLAP::ValueArg<std::string> graphFileArg("", "outputgraph",
		"[ConnectivityMatrix mode only] Output a file where each line is: [label index in the matrix] \\t [label value] \\t [x] \\t [y] \\t [z].", false,
		"", "file name",
		cmd);

	TCLAP::ValueArg<std::string> matrixMDArg("", "matrixMD",
		"[ConnectivityMatrix mode only] Output Weighted MD matrix File Name", false,
		"", "output weigthedMD matrix",
		cmd);

	TCLAP::ValueArg<std::string> matrixFAArg("", "matrixFA",
		"[ConnectivityMatrix mode only] Output Weighted FA matrix File Name", false,
		"", "output weigthedFA matrix",
		cmd);

	TCLAP::ValueArg<std::string> matrixArg("m", "matrix",
		"[ConnectivityMatrix mode only] Output connectivity matrix File Name", false,
		"", "output connectivity matrix",
		cmd);

	TCLAP::ValueArg<std::string> inputParcellationArg("", "parcellation",
		"Provides an input anatomy parcellation file and set the mode ConnectivityMatrix to true.", false,
		"", "input anatomy parcellation file",
		cmd);

	TCLAP::ValueArg<std::string> outputSeedingImgArg("", "outputseeding",
		"If using the --faroithreshold option, output the automatically created seeding image.", false,
		"", "output seeding file name",
		cmd);

	TCLAP::ValueArg<double > faROIArg("", "faroithreshold",
		"FA threshold used to generate the seeding ROI (default: 0.6)", false,
		0.6, "FA threshold",
		cmd);

	TCLAP::ValueArg<std::string> inputSeedingImgArg("", "seeding",
		"Define an image of seeding points (seeds from all non-null voxel). If not used, the seeding image will be automatically created from the treshold FA image (see --faroithreshold option).", false,
		"", "input label file name",
		cmd);

	TCLAP::ValueArg<std::string> outputArg("o", "outputFile",
		"Output Tract File Name (.vtk, .vtp or .gii file)", false,
		"", "output tract file name",
		cmd);

	TCLAP::ValueArg<std::string> fractionsFileArg("", "fractions",
		"Input 4D Fraction of Occupancy File Name", false,
		"", "input 4D file name",
		cmd);

	// Collect vector of input file names
	TCLAP::MultiArg<std::string> inputArg("i", "inputFile",
		"Input Tensor File Name", true,
		"input tensor file name",
		cmd);



	//------------------------------------------
	// Parse command line arguments
	//------------------------------------------
	try {
		cmd.parse(argc, argv);
	} catch (TCLAP::ArgException &e)
	{
		std::cerr << "Error: " << e.error() << "for argument " <<
			e.argId() << std::endl;
		exit (1);
	}

	//------------------------------------------
	// Get the values
	//------------------------------------------
	const std::vector<std::string> & inputNames = inputArg.getValue();
	const std::string&	outputName = outputArg.getValue();
	const std::string&	fractionsName = fractionsFileArg.getValue();
	const std::string&	interpMode = interpolationArg.getValue();
	const std::string&  inputParcellationImage = inputParcellationArg.getValue();
	const std::string&  inputSeedingImageName = inputSeedingImgArg.getValue();
	const std::string&	outputSeedingImageName = outputSeedingImgArg.getValue();

	std::string			dilatedLabelsImageName = dilatedLabelsArg.getValue();
	std::string			outputDensityBaseFileName = densityFileArg.getValue();
	std::string			outputConnMatrixName = matrixArg.getValue();
	std::string			outputFAMatrixName = matrixFAArg.getValue();
	std::string			outputMDMatrixName = matrixMDArg.getValue();
	std::string			outputGraphName = graphFileArg.getValue();

	bool				noProgress = noProgressArg.getValue();
	double				minimumFA  = faArg.getValue();
	double				faMomentum = faMomentumArg.getValue();
	double				maximumAngle = angleMaxArg.getValue();
	double				angleMomentum = angleMomentumArg.getValue();
	unsigned int		tractsPerVoxel = tractSeedsPerVoxelArg.getValue();
	unsigned int		stepsPerVoxel = stepsPerVoxelArg.getValue();
	double				directionMomentum = directionMomentumArg.getValue();
	double				tendFraction = tendFractionArg.getValue();
	double				faROI = faROIArg.getValue();
	unsigned int		voxelDilate = dilateLabelsArg.getValue();
	double				tractSimplifyAngle = tractSimplifyArg.getValue();

#ifdef MULTITHREAD_VERSION
	unsigned int		nbProc = argProc.getValue();
#endif

	//------------------------------------------
	// Some checking
	//------------------------------------------
	if ( inputParcellationImage=="" )	// Mode ConnectivityMatrix OFF
	{
		if ( outputConnMatrixName!="" ) 
		{
			std::cout<<"- Warning. No parcellation image provided. Option --matrix ignored"<<std::endl;
			outputConnMatrixName = "";
		}
		if ( outputFAMatrixName!="" ) 
		{
			std::cout<<"- Warning. No parcellation image provided. Option --matrixFA ignored"<<std::endl;
			outputFAMatrixName = "";
		}
		if ( outputMDMatrixName!="" ) 
		{
			std::cout<<"- Warning. No parcellation image provided. Option --matrixMD ignored"<<std::endl;
			outputMDMatrixName = "";
		}
		if ( outputDensityBaseFileName!="" ) 
		{
			std::cout<<"- Warning. No parcellation image provided. Option --outputdensity ignored"<<std::endl;
			outputDensityBaseFileName = "";
		}
		if ( outputGraphName!="" ) 
		{
			std::cout<<"- Warning. No parcellation image provided. Option --outputgraph ignored"<<std::endl;
			outputGraphName = "";
		}
		if ( dilatedLabelsImageName!="" ) 
		{
			std::cout<<"- Warning. No parcellation image provided. Option --dilatedlabels ignored"<<std::endl;
			dilatedLabelsImageName = "";
		}
		if ( voxelDilate!=0 ) 
		{
			std::cout<<"- Warning. No parcellation image provided. Option --dilatelabels ignored"<<std::endl;
			voxelDilate = 0;
		}
	}

	if ( outputName=="" && outputConnMatrixName=="" && outputFAMatrixName=="" && outputMDMatrixName=="" )
	{
		std::cout<<"- Error. When the ConnectivityMatrix is OFF (no --parcellation option), "<<std::endl;
		std::cout<<"  the output tract file name must be specified (option -o)."<<std::endl;
		exit(1);
	}


	

	//------------------------------------------
	// Prepare some variables
	//------------------------------------------
	typedef double ComponentTypeDouble;
	typedef float  ComponentTypeFloat;
	const unsigned int ImageDimension = 3;
	typedef   itk::SymmetricSecondRankTensor<ComponentTypeDouble, ImageDimension>  PixelTypeDouble;
	typedef   itk::OrientedImage< PixelTypeDouble, ImageDimension >  ImageTypeDouble;
	typedef   itk::ImageFileReader<ImageTypeDouble> ImageReaderTypeDouble;

	typedef crl::MFMWBConnectivity<ImageDimension, float> ConnectivityAnalysisFloatType;
	typedef crl::MFMWBConnectivity<ImageDimension, double> ConnectivityAnalysisDoubleType;

	//------------------------------------------
	// Determine if we instanciate the 'float tensors'
	// or the 'double tensors' class
	//------------------------------------------
	ImageReaderTypeDouble::Pointer reader = ImageReaderTypeDouble::New();
	reader->SetFileName( inputNames[0].c_str() );
	try {
		reader->GenerateOutputInformation();
	} catch (itk::ExceptionObject &excp)
	{
		std::cerr << "Failed to read from file " << inputNames[0] << std::endl;    
		std::cerr << "Exception error message is : " << excp << std::endl;
		return EXIT_FAILURE;
	}
    
	//------------------------------------------
	// Instantiate
	//------------------------------------------
	try {
		crl::MFMTractGeneratorBase::Pointer tsm;
		ConnectivityAnalysisDoubleType::Pointer algoDouble = NULL;
		ConnectivityAnalysisFloatType::Pointer algoFloat = NULL;

		itk::ImageIOBase *imageIO = reader->GetImageIO();

		//------------------------------------------
		// Component type of data on file is DOUBLE, so use filter templated
		// over double for this operation.
		//------------------------------------------
		if (imageIO->GetComponentType() == itk::ImageIOBase::DOUBLE) 
		{
			algoDouble = ConnectivityAnalysisDoubleType::New();
			tsm = algoDouble;
		}
		//------------------------------------------
		// Component type of data on file is FLOAT, so use filter templated
		// over float for this operation.	
		//------------------------------------------
		else if (imageIO->GetComponentType() == itk::ImageIOBase::FLOAT) {
			algoFloat = ConnectivityAnalysisFloatType::New();
			tsm = algoFloat;
		} 
		//------------------------------------------
		// Else error
		//------------------------------------------
		else {
			std::cerr << "File component type does not match expected type "
				<< " of float or double." << std::endl;
			std::cerr << "Use crlCastSymMat* to change the type of the components."
				<< std::endl;
			return EXIT_FAILURE;
		}

		//------------------------------------------
		// Set up the whole brain connectivity algo
		//------------------------------------------
		tsm->SetInputFileNames( inputNames );
		tsm->SetROIFileName( inputParcellationImage );			// The ROI is automatically generated for the whole brain connectivity. Instead we provide the file name of the parcellation 
		tsm->SetOutputFileName( outputName );
		tsm->SetFractionFileName( fractionsName );
		tsm->SetMinimumFA( minimumFA );
		tsm->SetFractionalAnisotropyMomentum( faMomentum ); 
		tsm->SetMaximumAngle( maximumAngle ); 
		tsm->SetAngleThresholdMomentum( angleMomentum ); 
		tsm->SetTractsPerVoxel( tractsPerVoxel );
		tsm->SetStepsPerVoxel( stepsPerVoxel );
		tsm->SetDirectionMomentum( directionMomentum );
		tsm->SetTendFraction( tendFraction );
		tsm->SetShowProgress( !noProgress );
		tsm->SetTractSimplificationMinAngle(tractSimplifyAngle);

		if ( algoDouble.GetPointer()!=NULL )
		{
			algoDouble->SetOutputMatrixFileName( outputConnMatrixName );
			algoDouble->SetOutputFAMatrixFileName(outputFAMatrixName);
			algoDouble->SetOutputMDMatrixFileName(outputMDMatrixName);
			algoDouble->SetThresholdToGenerateROI( faROI );
			algoDouble->SetSeedingImageFileName(inputSeedingImageName);
			algoDouble->SetOutputSeedingImageFileName(outputSeedingImageName);
			algoDouble->SetOutputDilatedLabelImage ( dilatedLabelsImageName );
			algoDouble->SetNbVoxelDilatation( voxelDilate );
			algoDouble->SetOutputTractDensityBaseFileName(outputDensityBaseFileName);
			algoDouble->SetGraphCoordinatesFileName(outputGraphName);

#ifdef MULTITHREAD_VERSION
			algoDouble->SetNbThreads((int)nbProc);
#endif
		}
		else if ( algoFloat.GetPointer()!=NULL )
		{
			algoFloat->SetOutputMatrixFileName( outputConnMatrixName );
			algoFloat->SetOutputFAMatrixFileName(outputFAMatrixName);
			algoFloat->SetOutputMDMatrixFileName(outputMDMatrixName);		algoFloat->SetThresholdToGenerateROI( faROI );
			algoFloat->SetSeedingImageFileName(inputSeedingImageName);
			algoFloat->SetOutputSeedingImageFileName(outputSeedingImageName);
			algoFloat->SetOutputDilatedLabelImage ( dilatedLabelsImageName );
			algoFloat->SetNbVoxelDilatation( voxelDilate );
			algoFloat->SetOutputTractDensityBaseFileName(outputDensityBaseFileName);
			algoFloat->SetGraphCoordinatesFileName(outputGraphName);

#ifdef MULTITHREAD_VERSION
			algoFloat->SetNbThreads((int)nbProc);
#endif
		}


		if ( interpMode=="euclidean" ) tsm->SetTensorInterpolationMode(crl::MFMTractGeneratorBase::INTERP_EUCLIDEAN);
		else if ( interpMode=="logeuclidean" ) tsm->SetTensorInterpolationMode(crl::MFMTractGeneratorBase::INTERP_LOGEUCLIDEAN);
		else tsm->SetTensorInterpolationMode(crl::MFMTractGeneratorBase::INTERP_NONE);



		// Could include an option to seed the random number generator to allow
		// reproducible runs.

		//------------------------------------------
		// RUN !
		//------------------------------------------
		int ret = tsm->Execute();

		//------------------------------------------
		// Check the error code
		//------------------------------------------
		if (ret != 0) {
			std::cerr << argv[0] << " failed with return error code " << ret <<
				std::endl;
			return EXIT_FAILURE;
		}
	}
	/*-------------------------------------
	If catched an exception, show a message
	-------------------------------------*/
	catch (itk::ExceptionObject& e)
	{
		std::cout<< "ITK EXCEPTION ERROR CAUGHT"<<std::endl<< e.GetDescription() << std::endl << "Cannot continue." << std::endl ;
		return EXIT_FAILURE;
	}
	catch ( ... )
	{
		std::cout<<"UNKNOWN EXCEPTION ERROR." << std::endl << "Cannot continue."<< std::endl;
		return EXIT_FAILURE;
	}

	return EXIT_SUCCESS;

};


#include "crlMFMTractGenerator.txx"
#include "crlMFMWBConnectivity.txx"
