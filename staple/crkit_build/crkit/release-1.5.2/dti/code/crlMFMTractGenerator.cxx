
#include <itkOrientedImage.h>
#include <itkImageFileReader.h>
#include <itkImageFileWriter.h>

#include "configuration.h"
#include "tclap/CmdLine.h"
#include <limits.h>

#ifdef WIN32
#define snprintf _snprintf
#define PATH_MAX 512
#endif

#include <math.h>
#include <float.h>

#include <vnl/vnl_matrix_fixed.h>
#include <vnl/vnl_det.h>

#include "crlMFMTractGenerator.h"

// Input: A set of tensor images, a labelled region of interest image
// Output: Streamline tracts generated by Euler integration.

int main(int argc, char **argv)
{

    // Define the command line object, and insert a message
    // that describes the program.
    TCLAP::CmdLine cmd("Computational Radiology Laboratory", ' ',
        CRKIT_VERSION_STRING );

	TCLAP::SwitchArg noProgressArg	("","noprogress",
			"Disable the output of the tract generator progress (useful for debugging).", cmd, false);

    TCLAP::ValueArg<double > faMomentumArg("", "famomentum",
		"Fractional Anisotropy Momentum (default: 0.5)", false,
            0.5, "fa momentum",
            cmd);

    TCLAP::ValueArg<double > angleMomentumArg("", "anglemomentum",
		"Angle Momentum (default: 0.5)", false,
            0.5, "angle momentum",
            cmd);

    TCLAP::ValueArg<double > directionMomentumArg("d", "directionmomentum",
		"Direction Momentum (default: 0.5)", false,
            0.5, "direction momentum",
            cmd);

    TCLAP::ValueArg<double > tendFractionArg("t", "tendfraction",
		"Tensor Deflection Fraction vs Eigenvector Fraction (default: 0.9)", false,
            0.9, "tensor deflection fraction",
            cmd);

    TCLAP::ValueArg<unsigned int> maxTractLengthArg("m", "maxlength",
		    "Max tract length (WARNING. Number of points, not mm) (default: 2000)" , false,
			2000, "Number of points",
            cmd);

    TCLAP::ValueArg<unsigned int> tractSeedsPerVoxelArg("n", "numtractseeds",
            "Number of Tract Seeds Per Voxel", false,
			1, "Number of tract seeds per voxel (default: 1)",
            cmd);

    TCLAP::ValueArg<unsigned int> stepsPerVoxelArg("s", "stepspervoxel",
		"Number of Steps per Voxel (default: 3)", false,
            3, "number of steps per voxel",
            cmd);


    std::vector<std::string> strInterpModes;
	strInterpModes.push_back("none");
	strInterpModes.push_back("euclidean");
	strInterpModes.push_back("logeuclidean");
	TCLAP::ValuesConstraint<std::string> interpModesArg(strInterpModes);
	TCLAP::ValueArg<std::string> interpolationArg("","interp","Tensor interpolation mode : none, euclidean interpolation or log-euclidean interpolation (default: logeuclidean)",false,"logeuclidean", &interpModesArg, cmd);

    TCLAP::ValueArg<std::string> fractionsFileArg("", "fractions",
            "Input 4D Fraction of Occupancy File Name", false,
            "", "input 4D file name",
            cmd);

	TCLAP::ValueArg<std::string> outputArg("o", "outputFile",
            "Output Tract File Name (.vtk, .vtp or .gii file)", true,
            "/dev/null", "output tract file name",
            cmd);

    TCLAP::ValueArg<double > faArg("f", "famin",
            "Minimum FA Value", true,
            0.15, "minimum fa value",
            cmd);

	TCLAP::ValueArg<double > angleMaxArg("a", "anglemax",
            "Maximum Angle Value in degrees", true,
            80, "maximum angle value",
            cmd);

	TCLAP::MultiArg<unsigned int> roiSeedLabelArg("l", "labelofseed",
            "Label of Seed Value. Several -l options can be defined to use several ROIs.", true,
            "label of seed value",
            cmd);

	TCLAP::ValueArg<std::string> roiFileArg("r", "roiFile",
            "Input ROI File Name", true,
            "/dev/null", "input roi file name",
            cmd);

    // Collect vector of input file names
    TCLAP::MultiArg<std::string> inputArg("i", "inputFile",
            "Input Tensor File Name", true,
            "input tensor file name",
            cmd);




  // Parse command line arguments
  try {
    cmd.parse(argc, argv);
  } catch (TCLAP::ArgException &e)
  {
    std::cerr << "Error: " << e.error() << "for argument " <<
      e.argId() << std::endl;
    exit (1);
  }

  const std::vector<std::string> & inputNames = inputArg.getValue();
  const std::string& outputName = outputArg.getValue();
  const std::string& roiName = roiFileArg.getValue();
  const std::string& fractionsName = fractionsFileArg.getValue();
  std::vector<unsigned int> roiLabels = roiSeedLabelArg.getValue();
  const std::string&	interpMode = interpolationArg.getValue();
  bool					noProgress = noProgressArg.getValue();
  unsigned int			maxTractLength = maxTractLengthArg.getValue();

  double minimumFA = faArg.getValue();
  double faMomentum = 0.5;
  if (faMomentumArg.isSet()) {
    faMomentum = faMomentumArg.getValue();
  }

  double maximumAngle = 80;
  if (angleMaxArg.isSet()) {
    maximumAngle = angleMaxArg.getValue();
  }

  double angleMomentum = 0.5;
  if (angleMomentumArg.isSet()) {
    angleMomentum = angleMomentumArg.getValue();
  }

  unsigned int tractsPerVoxel = 1;
  if (tractSeedsPerVoxelArg.isSet()) {
    tractsPerVoxel = tractSeedsPerVoxelArg.getValue();
  }

  unsigned int stepsPerVoxel = 3;
  if (stepsPerVoxelArg.isSet()) {
    stepsPerVoxel = stepsPerVoxelArg.getValue();
  }

  double directionMomentum = 0.5;
  if (directionMomentumArg.isSet()) {
    directionMomentum = directionMomentumArg.getValue();
  }

  double tendFraction = 0.9;
  if (tendFractionArg.isSet()) {
    tendFraction = tendFractionArg.getValue();
  }

  typedef double ComponentTypeDouble;
  typedef float  ComponentTypeFloat;
  const unsigned int ImageDimension = 3;
  typedef   itk::SymmetricSecondRankTensor<ComponentTypeDouble, ImageDimension>  PixelTypeDouble;
  typedef   itk::OrientedImage< PixelTypeDouble, ImageDimension >  ImageTypeDouble;
  typedef   itk::ImageFileReader<ImageTypeDouble> ImageReaderTypeDouble;

  ImageReaderTypeDouble::Pointer reader = ImageReaderTypeDouble::New();
  reader->SetFileName( inputNames[0].c_str() );

  try {
    reader->GenerateOutputInformation();
  } catch (itk::ExceptionObject &excp)
  {
    std::cerr << "Failed to read from file " << inputNames[0] << std::endl;    
    std::cerr << "Exception error message is : " << excp << std::endl;
    return EXIT_FAILURE;
  }

  crl::MFMTractGeneratorBase::Pointer tsm;

  itk::ImageIOBase *imageIO = reader->GetImageIO();
  if (imageIO->GetComponentType() == itk::ImageIOBase::DOUBLE) {
   // Component type of data on file is DOUBLE, so use filter templated
   // over double for this operation.
   tsm = crl::MFMTractGenerator<ImageDimension, double>::New();
  } else if (imageIO->GetComponentType() == itk::ImageIOBase::FLOAT) {
   // Component type of data on file is FLOAT, so use filter templated
   // over float for this operation.
   tsm = crl::MFMTractGenerator<ImageDimension, float>::New();
  } else {
    std::cerr << "File component type does not match expected type "
       << " of float or double." << std::endl;
    std::cerr << "Use crlCastSymMat* to change the type of the components."
              << std::endl;
    return EXIT_FAILURE;
  }

  tsm->SetInputFileNames( inputNames );
  tsm->SetROIFileName( roiName );
  tsm->SetOutputFileName( outputName );
  tsm->SetFractionFileName( fractionsName );
  for ( unsigned int labelID=0; labelID<roiLabels.size(); labelID++ ) tsm->AddROILabel( roiLabels.at(labelID) );
  tsm->SetMinimumFA( minimumFA );
  tsm->SetFractionalAnisotropyMomentum( faMomentum ); 
  tsm->SetMaximumAngle( maximumAngle ); 
  tsm->SetAngleThresholdMomentum( angleMomentum ); 
  tsm->SetTractsPerVoxel( tractsPerVoxel );
  tsm->SetStepsPerVoxel( stepsPerVoxel );
  tsm->SetDirectionMomentum( directionMomentum );
  tsm->SetTendFraction( tendFraction );
  tsm->SetMaximumTractLength(maxTractLength);
  tsm->SetShowProgress( !noProgress );

  if ( interpMode=="euclidean" ) tsm->SetTensorInterpolationMode(crl::MFMTractGeneratorBase::INTERP_EUCLIDEAN);
  else if ( interpMode=="logeuclidean" ) tsm->SetTensorInterpolationMode(crl::MFMTractGeneratorBase::INTERP_LOGEUCLIDEAN);
  else tsm->SetTensorInterpolationMode(crl::MFMTractGeneratorBase::INTERP_NONE);

  // Could include an option to seed the random number generator to allow
  // reproducible runs.

  int ret = tsm->Execute();

  if (ret != 0) {
    std::cerr << argv[0] << " failed with return error code " << ret <<
    std::endl;
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;

};

#include "crlMFMTractGenerator.txx"

