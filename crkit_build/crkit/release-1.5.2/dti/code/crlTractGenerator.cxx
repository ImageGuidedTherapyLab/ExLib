
#include <itkOrientedImage.h>
#include <itkImageFileReader.h>
#include <itkImageFileWriter.h>

#include "configuration.h"
#include "tclap/CmdLine.h"
#include <limits.h>

#ifdef WIN32
#define snprintf _snprintf
#define PATH_MAX 512
#endif

#include <math.h>
#include <float.h>

#include <vnl/vnl_matrix_fixed.h>
#include <vnl/vnl_det.h>

#include "crlTractGenerator.h"

// Input: A tensor image, a labelled region of interest image
// Output: Streamline tracts generated by Euler integration.

int main(int argc, char **argv)
{

    // Define the command line object, and insert a message
    // that describes the program.
    TCLAP::CmdLine cmd("Computational Radiology Laboratory", ' ',
        CRKIT_VERSION_STRING );

    // Define input file name
    TCLAP::ValueArg<std::string> inputArg("i", "inputFile",
            "Input Tensor File Name", true,
            "/dev/null", "input tensor file name",
            cmd);

    TCLAP::ValueArg<std::string> outputArg("o", "outputFile",
            "Output Tract File Name", true,
            "/dev/null", "output tract file name",
            cmd);

    TCLAP::ValueArg<std::string> roiFileArg("r", "roiFile",
            "Input ROI File Name", true,
            "/dev/null", "input roi file name",
            cmd);

    TCLAP::ValueArg<unsigned int> roiSeedLabelArg("l", "labelofseed",
            "Label of Seed Value", true,
            1, "label of seed value",
            cmd);

    TCLAP::ValueArg<double > faMomentumArg("", "famomentum",
            "Fractional Anisotropy Momentum", false,
            0.0, "fa momentum",
            cmd);

    TCLAP::ValueArg<double > faArg("f", "famin",
            "Minimum FA Value", true,
            0.15, "minimum fa value",
            cmd);

    TCLAP::ValueArg<double > angleMaxArg("a", "anglemax",
            "Maximum Angle Value in degrees (80.0)", true,
            80, "maximum angle value",
            cmd);

    TCLAP::ValueArg<double > angleMomentumArg("", "anglemomentum",
            "Angle Momentum", false,
            0.5, "angle momentum",
            cmd);

    TCLAP::ValueArg<double > directionMomentumArg("d", "directionmomentum",
            "Direction Momentum", false,
            0.1, "direction momentum",
            cmd);

    TCLAP::ValueArg<double > tendFractionArg("t", "tendfraction",
            "Tensor Deflection Fraction vs Eigenvector Fraction", false,
            0.9, "tensor deflection fraction",
            cmd);

    TCLAP::ValueArg<unsigned int> tractSeedsPerVoxelArg("n", "numtractseeds",
            "Number of Tract Seeds Per Voxel", false,
            1, "number of tract seeds per voxel",
            cmd);

    TCLAP::ValueArg<unsigned int> stepsPerVoxelArg("s", "stepspervoxel",
            "Number of Steps per Voxel", false,
            3, "number of steps per voxel",
            cmd);

  // Parse command line arguments
  try {
    cmd.parse(argc, argv);
  } catch (TCLAP::ArgException &e)
  {
    std::cerr << "Error: " << e.error() << "for argument " <<
      e.argId() << std::endl;
    exit (1);
  }

  const std::string& inputName = inputArg.getValue();
  const std::string& outputName = outputArg.getValue();
  const std::string& roiName = roiFileArg.getValue();
  int roiLabel = roiSeedLabelArg.getValue();

  double minimumFA = faArg.getValue();
  double faMomentum = 0.0;
  if (faMomentumArg.isSet()) {
    faMomentum = faMomentumArg.getValue();
  }

  double maximumAngle = 80;
  if (angleMaxArg.isSet()) {
    maximumAngle = angleMaxArg.getValue();
  }

  double angleMomentum = 0.5;
  if (angleMomentumArg.isSet()) {
    angleMomentum = angleMomentumArg.getValue();
  }

  unsigned int tractsPerVoxel = 1;
  if (tractSeedsPerVoxelArg.isSet()) {
    tractsPerVoxel = tractSeedsPerVoxelArg.getValue();
  }

  unsigned int stepsPerVoxel = 3;
  if (stepsPerVoxelArg.isSet()) {
    stepsPerVoxel = stepsPerVoxelArg.getValue();
  }

  double directionMomentum = 0.1;
  if (directionMomentumArg.isSet()) {
    directionMomentum = directionMomentumArg.getValue();
  }

  double tendFraction = 0.9;
  if (tendFractionArg.isSet()) {
    tendFraction = tendFractionArg.getValue();
  }

  typedef double ComponentTypeDouble;
  typedef float  ComponentTypeFloat;
  const unsigned int ImageDimension = 3;
  typedef   itk::SymmetricSecondRankTensor<ComponentTypeDouble, ImageDimension>  PixelTypeDouble;
  typedef   itk::OrientedImage< PixelTypeDouble, ImageDimension >  ImageTypeDouble;
  typedef   itk::ImageFileReader<ImageTypeDouble> ImageReaderTypeDouble;

  ImageReaderTypeDouble::Pointer reader = ImageReaderTypeDouble::New();
  reader->SetFileName( inputName.c_str() );

  try {
    reader->GenerateOutputInformation();
  } catch (itk::ExceptionObject &excp)
  {
    std::cerr << "Failed to read from file " << inputName << std::endl;    
    std::cerr << "Exception error message is : " << excp << std::endl;
    return EXIT_FAILURE;
  }

  crl::TractGeneratorBase::Pointer tsm;

  itk::ImageIOBase *imageIO = reader->GetImageIO();
  if (imageIO->GetComponentType() == itk::ImageIOBase::DOUBLE) {
   // Component type of data on file is DOUBLE, so use filter templated
   // over double for this operation.
   tsm = crl::TractGenerator<ImageDimension, double>::New();
  } else if (imageIO->GetComponentType() == itk::ImageIOBase::FLOAT) {
   // Component type of data on file is FLOAT, so use filter templated
   // over float for this operation.
   tsm = crl::TractGenerator<ImageDimension, float>::New();
  } else {
    std::cerr << "File component type does not match expected type "
       << " of float or double." << std::endl;
    std::cerr << "Use crlCastSymMat* to change the type of the components."
              << std::endl;
    return EXIT_FAILURE;
  }

  tsm->SetInputFileName( inputName.c_str() );
  tsm->SetROIFileName( roiName.c_str() );
  tsm->SetOutputFileName( outputName.c_str() );
  tsm->SetROILabel( roiLabel );
  tsm->SetMinimumFA( minimumFA );
  tsm->SetFractionalAnisotropyMomentum( faMomentum ); 
  tsm->SetMaximumAngle( maximumAngle ); 
  tsm->SetAngleThresholdMomentum( angleMomentum ); 
  tsm->SetTractsPerVoxel( tractsPerVoxel );
  tsm->SetStepsPerVoxel( stepsPerVoxel );
  tsm->SetDirectionMomentum( directionMomentum );
  tsm->SetTendFraction( tendFraction );
  // Could include an option to seed the random number generator to allow
  // reproducible runs.

  int ret = tsm->Execute();

  if (ret != 0) {
    std::cerr << argv[0] << " failed with return error code " << ret <<
    std::endl;
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;

};

#include "crlTractGenerator.txx"

